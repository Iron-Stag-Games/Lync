{"version":3,"file":"_parse.js","sourceRoot":"","sources":["../../src/_parse.ts"],"names":[],"mappings":"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","sourcesContent":["// parse a single path portion\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions } from './index.js'\nimport { assertValidPattern } from './assert-valid-pattern.js'\n\nconst globUnescape = (s: string) => s.replace(/\\\\(.)/g, '$1')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// \"abc\" -> { a:true, b:true, c:true }\nconst charSet = (s: string) =>\n  s.split('').reduce((set: { [k: string]: boolean }, c) => {\n    set[c] = true\n    return set\n  }, {})\n\nconst plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)' },\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' },\n}\n\n// characters that need to be escaped in RegExp.\nconst reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// characters that indicate we have to add the pattern start\nconst addPatternStartSet = charSet('[.(')\n\ntype StateChar = '!' | '?' | '+' | '*' | '@'\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\ninterface PatternListEntry {\n  type: string\n  start: number\n  reStart: number\n  open: string\n  close: string\n}\n\ninterface NegativePatternListEntry extends PatternListEntry {\n  reEnd: number\n}\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\n// TODO: take an offset and length, so we can sub-parse the extglobs\nexport const parse = (\n  options: MinimatchOptions,\n  pattern: string,\n  debug: (...a: any[]) => void,\n): false | string => {\n  assertValidPattern(pattern)\n\n  if (pattern === '') return ''\n\n  let re = ''\n  let hasMagic = false\n  let escaping = false\n  // ? => one single character\n  const patternListStack: PatternListEntry[] = []\n  const negativeLists: NegativePatternListEntry[] = []\n  let stateChar: StateChar | false = false\n  let uflag = false\n  let pl: PatternListEntry | undefined\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.  However, if the pattern\n  // starts with ., then traversal patterns can match.\n  let dotTravAllowed = pattern.charAt(0) === '.'\n  let dotFileAllowed = options.dot || dotTravAllowed\n  const patternStart = () =>\n    dotTravAllowed\n      ? ''\n      : dotFileAllowed\n      ? '(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))'\n      : '(?!\\\\.)'\n  const subPatternStart = (p: string) =>\n    p.charAt(0) === '.'\n      ? ''\n      : options.dot\n      ? '(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))'\n      : '(?!\\\\.)'\n\n  const clearStateChar = () => {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n          break\n        case '?':\n          re += qmark\n          hasMagic = true\n          break\n        default:\n          re += '\\\\' + stateChar\n          break\n      }\n      debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (\n    let i = 0, c: string;\n    i < pattern.length && (c = pattern.charAt(i));\n    i++\n  ) {\n    debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping) {\n      // completely not allowed, even escaped.\n      // should be impossible.\n      /* c8 ignore start */\n      if (c === '/') {\n        return false\n      }\n      /* c8 ignore stop */\n\n      if (reSpecials[c]) {\n        re += '\\\\'\n      }\n      re += c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      // Should already be path-split by now.\n      /* c8 ignore start */\n      case '/': {\n        return false\n      }\n      /* c8 ignore stop */\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n        continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n        continue\n\n      case '(': {\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        const plEntry: PatternListEntry = {\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close,\n        }\n        debug(pattern, '\\t', plEntry)\n        patternListStack.push(plEntry)\n        // negation is (?:(?!(?:js)(?:<rest>))[^/]*)\n        re += plEntry.open\n        // next entry starts with a dot maybe?\n        if (plEntry.start === 0 && plEntry.type !== '!') {\n          dotTravAllowed = true\n          re += subPatternStart(pattern.slice(i + 1))\n        }\n        debug('plType %j %j', stateChar, re)\n        stateChar = false\n        continue\n      }\n\n      case ')': {\n        const plEntry = patternListStack[patternListStack.length - 1]\n        if (!plEntry) {\n          re += '\\\\)'\n          continue\n        }\n        patternListStack.pop()\n\n        // closing an extglob\n        clearStateChar()\n        hasMagic = true\n        pl = plEntry\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(Object.assign(pl, { reEnd: re.length }))\n        }\n        continue\n      }\n\n      case '|': {\n        const plEntry = patternListStack[patternListStack.length - 1]\n        if (!plEntry) {\n          re += '\\\\|'\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n        // next subpattern can start with a dot?\n        if (plEntry.start === 0 && plEntry.type !== '!') {\n          dotTravAllowed = true\n          re += subPatternStart(pattern.slice(i + 1))\n        }\n        continue\n      }\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n        const [src, needUflag, consumed, magic] = parseClass(pattern, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n        } else {\n          re += '\\\\['\n        }\n        continue\n\n      case ']':\n        re += '\\\\' + c\n        continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        re += regExpEscape(c)\n        break\n    } // switch\n  } // for\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    let tail: string\n    tail = re.slice(pl.reStart + pl.open.length)\n    debug(pattern, 'setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, (_, $1, $2) => {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n        // should already be done\n        /* c8 ignore start */\n      }\n      /* c8 ignore stop */\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    debug('tail=%j\\n   %s', tail, tail, pl, re)\n    const t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  const addPatternStart = addPatternStartSet[re.charAt(0)]\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (let n = negativeLists.length - 1; n > -1; n--) {\n    const nl = negativeLists[n]\n\n    const nlBefore = re.slice(0, nl.reStart)\n    const nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    let nlAfter = re.slice(nl.reEnd)\n    const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    const closeParensBefore = nlBefore.split(')').length\n    const openParensBefore = nlBefore.split('(').length - closeParensBefore\n    let cleanAfter = nlAfter\n    for (let i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    const dollar = nlAfter === '' ? '(?:$|\\\\/)' : ''\n\n    re = nlBefore + nlFirst + nlAfter + dollar + nlLast\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart() + re\n  }\n\n  // if it's nocase, and the lcase/uppercase don't match, it's magic\n  if (options.nocase && !hasMagic && !options.nocaseMagicOnly) {\n    hasMagic = pattern.toUpperCase() !== pattern.toLowerCase()\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(re)\n  }\n\n  return re\n}\n"]}